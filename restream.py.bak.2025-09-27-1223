from datetime import datetime, timedelta
# --- MAILCAM: delivery today helper ---
def _delivery_today_lines(state_path="/var/tmp/mailcam_delivery_state.json", max_items=8):
    import json, os, datetime as dt
    try:
        with open(state_path, "r") as f:
            st = json.load(f)
        items = st.get("today", [])
    except Exception:
        items = []
    lines = []
    if not items:
        return ["NONE"]
    # most recent first; each as two lines: Name, then MM-DD-YY HH:MM
    for e in sorted(items, key=lambda x: int(x.get("ts",0)), reverse=True)[:max_items]:
        name = str(e.get("name","?")).upper()
        ts   = dt.datetime.fromtimestamp(int(e.get("ts",0))).strftime("%m-%d-%y %H:%M")
        lines.append(name)
        lines.append(ts)
    return lines
# --- end helper ---

import os
import time
import json
import io, time, threading, requests, numpy as np, os, json, math
from PIL import Image, ImageDraw, ImageFont
from fastapi import FastAPI
from fastapi.responses import StreamingResponse, JSONResponse
import paho.mqtt.client as mqtt
import uvicorn

# ===== Config (env overrides) =====
SRC   = os.environ.get("MAILCAM_SOURCE",  "http://10.0.0.2:8123/local/mailcam/latest.jpg")
DEL_M = os.path.expanduser(os.environ.get("MAILCAM_MODEL_DELIVERY",  "~/models/delivery.onnx"))
COCO_M= os.path.expanduser(os.environ.get("MAILCAM_MODEL_COCO",      "~/models/yolov8n.onnx"))
DEL_L = os.path.expanduser(os.environ.get("MAILCAM_LABELS_DELIVERY", "~/models/delivery.names"))

CONF_DEL = float(os.environ.get("MAILCAM_CONF_DEL", "0.40"))
CONF_COCO= float(os.environ.get("MAILCAM_CONF_COCO","0.25"))
NMS_THR  = float(os.environ.get("MAILCAM_NMS",      "0.45"))
MIN_AREA = float(os.environ.get("MAILCAM_MINA",     "0.0008"))
IOU_KEEP = float(os.environ.get("MAILCAM_TIOU",     "0.60"))
MAX_AGE  = float(os.environ.get("MAILCAM_TAGE",     "1.2"))
MIN_HITS = int(os.environ.get("MAILCAM_MINHIT",     "3"))

MQTT_HOST=os.environ.get("MAILCAM_MQTT_HOST","10.0.0.2")
MQTT_USER=os.environ.get("MAILCAM_MQTT_USER","delivery")
MQTT_PASS=os.environ.get("MAILCAM_MQTT_PASS","gbk-29-bbx!")
MQTT_TOPIC=os.environ.get("MAILCAM_MQTT_TOPIC","home/mailcam/delivery")

OUT_W, OUT_H = 1280, 720
VID_W, VID_H = 960, 720

# ===== Labels =====
def load_names_fallback_coco():
    return ["person","bicycle","car","motorcycle","airplane","bus","train","truck","boat",
            "traffic light","fire hydrant","stop sign","parking meter","bench","bird","cat",
            "dog","horse","sheep","cow","elephant","bear","zebra","giraffe","backpack",
            "umbrella","handbag","tie","suitcase","frisbee","skis","snowboard","sports ball",
            "kite","baseball bat","baseball glove","skateboard","surfboard","tennis racket",
            "bottle","wine glass","cup","fork","knife","spoon","bowl","banana","apple",
            "sandwich","orange","broccoli","carrot","hot dog","pizza","donut","cake","chair",
            "couch","potted plant","bed","dining table","toilet","tv","laptop","mouse",
            "remote","keyboard","cell phone","microwave","oven","toaster","sink","refrigerator",
            "book","clock","vase","scissors","teddy bear","hair drier","toothbrush"]

def read_names(path, fallback=None):
    if os.path.isfile(path):
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            return [ln.strip() for ln in f if ln.strip()]
    return fallback or []

DELIVERY_KEYS = {"usps","ups","fedex","amazon"}

# ===== Engines (ORT preferred; fallback OpenCV) =====
def ort_or_cv_load(model_path):
    try:
        import onnxruntime as ort
        sess = ort.InferenceSession(model_path, providers=["CPUExecutionProvider"])
        inp  = sess.get_inputs()[0].name
        def infer(img640):
            arr = np.asarray(img640).astype(np.float32)/255.0
            arr = arr.transpose(2,0,1)[None,...]
            return sess.run(None, {inp: arr})
        return ("ORT", infer)
    except Exception:
        import cv2
        net = cv2.dnn.readNetFromONNX(model_path)
        def infer(img640):
            blob = cv2.dnn.blobFromImage(np.asarray(img640), 1/255.0, (640,640), swapRB=True)
            net.setInput(blob); return [net.forward()]
        return ("CV", infer)

DEL_OK = os.path.isfile(DEL_M)
COCO_OK= os.path.isfile(COCO_M)

DEL_LABELS = read_names(DEL_L, fallback=["usps","ups","fedex","amazon"])
COCO_LABELS= load_names_fallback_coco()

ENG_DEL, INFER_DEL = (("MISSING", None) if not DEL_OK else ort_or_cv_load(DEL_M))
ENG_COCO,INFER_COCO= (("MISSING", None) if not COCO_OK else ort_or_cv_load(COCO_M))

# ===== Utils =====
def letterbox(im, new_shape=(640,640), color=(114,114,114)):
    iw, ih = im.size; w, h = new_shape
    s = min(w/iw, h/ih); nw, nh = int(iw*s), int(ih*s)
    rsz = im.resize((nw, nh), Image.BILINEAR)
    canvas = Image.new("RGB", new_shape, color); canvas.paste(rsz, ((w-nw)//2, (h-nh)//2))
    return canvas, s, ((w-nw)//2, (h-nh)//2), (iw, ih)

def nms(xyxy, scores, thr):
    idx = np.argsort(-scores); keep=[]
    while idx.size:
        i = idx[0]; keep.append(i)
        if idx.size==1: break
        rest = idx[1:]
        xx1 = np.maximum(xyxy[i,0], xyxy[rest,0])
        yy1 = np.maximum(xyxy[i,1], xyxy[rest,1])
        xx2 = np.minimum(xyxy[i,2], xyxy[rest,2])
        yy2 = np.minimum(xyxy[i,3], xyxy[rest,3])
        inter = np.maximum(0, xx2-xx1)*np.maximum(0, yy2-yy1)
        a_i = (xyxy[i,2]-xyxy[i,0])*(xyxy[i,3]-xyxy[i,1])
        a_r = (xyxy[rest,2]-xyxy[rest,0])*(xyxy[rest,3]-xyxy[rest,1])
        iou = inter / (a_i + a_r - inter + 1e-6)
        idx = rest[iou < thr]
    return keep

def sigmoid(x): return 1.0/(1.0+np.exp(-x))

def _ensure_probs(obj, cls):
    """
    Some YOLOv8 ONNX exports output logits; others already output probs.
    Apply sigmoid unless values already look like probabilities (0..1).
    """
    # Heuristic: if max > 1.5 or min < -0.5, treat as logits.
    if (np.max(obj) > 1.5) or (np.min(obj) < -0.5) or (np.max(cls) > 1.5) or (np.min(cls) < -0.5):
        return sigmoid(obj), sigmoid(cls)
    return obj, cls

def decode_common(outs, conf_thr, iw, ih, pad, scale, nc_hint=None):
    """
    Accepts Ultralytics-style YOLOv8 ONNX outputs (either [1,84,8400] or [1,8400,84])
    and returns filtered boxes/ids/scores in image coordinates.
    """
    o = outs[0]
    if o.ndim == 3: o = o[0]                  # [84,8400] or [8400,84]
    if o.shape[0] < o.shape[1]: o = o.T       # -> [8400,84]
    if o.shape[1] < 6:                        # safety
        return np.zeros((0,4)), np.zeros((0,),int), np.zeros((0,))

    xywh = o[:, :4]
    obj  = o[:, 4]
    cls  = o[:, 5:]
    # Convert logits -> probabilities if needed
    obj, cls = _ensure_probs(obj, cls)

    # confidence = objectness * best class prob
    cls_best = np.argmax(cls, axis=1)
    cls_max  = cls[np.arange(cls.shape[0]), cls_best]
    conf     = obj * cls_max

    m = conf >= conf_thr
    if not np.any(m):
        return np.zeros((0,4)), np.zeros((0,),int), np.zeros((0,))

    xywh, cls_best, conf = xywh[m], cls_best[m], conf[m]

    # xywh -> xyxy (in letterboxed space), then de-letterbox to original image
    xyxy = np.empty_like(xywh)
    xyxy[:,0] = xywh[:,0] - xywh[:,2]/2
    xyxy[:,1] = xywh[:,1] - xywh[:,3]/2
    xyxy[:,2] = xywh[:,0] + xywh[:,2]/2
    xyxy[:,3] = xywh[:,1] + xywh[:,3]/2
    px, py = pad
    xyxy[:,[0,2]] = (xyxy[:,[0,2]] - px) / scale
    xyxy[:,[1,3]] = (xyxy[:,[1,3]] - py) / scale
    xyxy[:,0] = np.clip(xyxy[:,0], 0, iw-1)
    xyxy[:,1] = np.clip(xyxy[:,1], 0, ih-1)
    xyxy[:,2] = np.clip(xyxy[:,2], 0, iw-1)
    xyxy[:,3] = np.clip(xyxy[:,3], 0, ih-1)

    # area filter
    A = (xyxy[:,2]-xyxy[:,0])*(xyxy[:,3]-xyxy[:,1])
    keep_area = (A / (iw*ih)) >= MIN_AREA
    if not np.any(keep_area):
        return np.zeros((0,4)), np.zeros((0,),int), np.zeros((0,))

    xyxy, cls_best, conf = xyxy[keep_area], cls_best[keep_area], conf[keep_area]

    # NMS
    if xyxy.shape[0] > 1:
        keep = nms(xyxy, conf, NMS_THR)
        xyxy, cls_best, conf = xyxy[keep], cls_best[keep], conf[keep]

    return xyxy, cls_best, conf

# ===== State & MQTT =====
cur_frame=None
cur_meta = {"ts":0,"delivery":{},"objects":[],"ids":[],"engines":{},"models":{}}
next_id=1
tracks={}
last_delivery_set = set()

mqtt_client = None
def mqtt_connect():
    global mqtt_client
    try:
        import paho.mqtt.client as paho
        c = paho.Client()
        if MQTT_USER or MQTT_PASS:
            c.username_pw_set(MQTT_USER, MQTT_PASS)
        c.connect(MQTT_HOST, 1883, 30)
        mqtt_client = c
    except Exception:
        mqtt_client = None

def mqtt_publish(payload: dict):
    if not mqtt_client: return
    try:
        mqtt_client.publish(MQTT_TOPIC, json.dumps(payload), qos=1, retain=False)
    except Exception:
        pass

# ===== Main detection/render loop =====
def detect_and_render():
    global cur_frame, cur_meta, next_id, tracks, last_delivery_set
    try:
        font = ImageFont.truetype("DejaVuSans.ttf", 18)
        font_big = ImageFont.truetype("DejaVuSans.ttf", 22)
    except Exception:
        font = ImageFont.load_default(); font_big = font

    COCO_KEEP = {"person","car","truck","bus","bicycle","motorcycle"}
    while True:
        t0=time.time()
        try:
            r = requests.get(SRC, timeout=3); r.raise_for_status()
            im = Image.open(io.BytesIO(r.content)).convert("RGB")
        except Exception:
            time.sleep(0.3); continue

        lb, scale, pad, (iw, ih) = letterbox(im, (640,640))

        # Inference
        del_xy=del_id=del_sc=np.zeros((0,4)),np.zeros((0,),int),np.zeros((0,))
        coco_xy=coco_id=coco_sc=np.zeros((0,4)),np.zeros((0,),int),np.zeros((0,))
        if DEL_OK and INFER_DEL:
            out = INFER_DEL(lb)
            del_xy, del_id, del_sc = decode_common(out, CONF_DEL, iw, ih, pad, scale, nc_hint=len(DEL_LABELS) if DEL_LABELS else None)
        if COCO_OK and INFER_COCO:
            out = INFER_COCO(lb)
            coco_xy, coco_id, coco_sc = decode_common(out, CONF_COCO, iw, ih, pad, scale, nc_hint=80)

        # Merge detections for tracking
        det_boxes=[]; det_names=[]; det_scores=[]
        for b,i,s in zip(del_xy, del_id, del_sc):
            nm = (DEL_LABELS[i] if i<len(DEL_LABELS) else str(int(i)))
            det_boxes.append(b); det_names.append(nm); det_scores.append(float(s))
        COCO80 = load_names_fallback_coco()
        for b,i,s in zip(coco_xy, coco_id, coco_sc):
            nm = (COCO80[i] if i < 80 else str(int(i)))
            if nm in COCO_KEEP:
                det_boxes.append(b); det_names.append(nm); det_scores.append(float(s))

        # Tracker
        now=time.time()
        tracks={tid:t for tid,t in tracks.items() if now - t["last"] <= MAX_AGE}
        assigned=set()
        for b,nm,sc in zip(det_boxes, det_names, det_scores):
            best,bid=0.0,None
            for tid,t in tracks.items():
                if t["clsname"]!=nm: continue
                # IoU
                ax1,ay1,ax2,ay2 = b; bx1,by1,bx2,by2 = t["box"]
                iw_=max(0,min(ax2,bx2)-max(ax1,bx1)); ih_=max(0,min(ay2,by2)-max(ay1,by1))
                inter=iw_*ih_; 
                if inter>0:
                    aa=(ax2-ax1)*(ay2-ay1); ba=(bx2-bx1)*(by2-by1)
                    j=inter/(aa+ba-inter+1e-6)
                else:
                    j=0.0
                if j>best: best=j; bid=tid
            if bid is not None and best>=IOU_KEEP and bid not in assigned:
                t=tracks[bid]; t["box"]=tuple(b); t["last"]=now; t["hits"]=min(t["hits"]+1,999)
                assigned.add(bid)
            else:
                tid=next_id; next_id+=1
                tracks[tid]={"box":tuple(b),"clsname":nm,"last":now,"hits":1}

        stable={tid:t for tid,t in tracks.items() if t["hits"]>=MIN_HITS}
        names_present=set(t["clsname"].lower() for t in stable.values())
        dflags={k:(k in names_present) for k in DELIVERY_KEYS}
        present = [k for k,v in dflags.items() if v]
        present_set = set(present)

        # Notify when set changes
        if present_set != last_delivery_set:
            ts = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
            mqtt_publish({"timestamp": ts, "services": sorted(list(present_set))})
            last_delivery_set = present_set

        # ===== Compose canvas =====
        canvas = Image.new("RGB", (OUT_W, OUT_H), (16,16,16))
        vid = im.resize((VID_W, VID_H), Image.BILINEAR); canvas.paste(vid,(0,0))
        draw = ImageDraw.Draw(canvas)

        # Boxes (stable only)
        sx,sy = VID_W/iw, VID_H/ih
        for tid,t in stable.items():
            x1,y1,x2,y2 = t["box"]
            X1,Y1,X2,Y2 = int(x1*sx), int(y1*sy), int(x2*sx), int(y2*sy)
            nm=t["clsname"]
            draw.rectangle([X1,Y1,X2,Y2], outline=(0,255,0), width=3)
            lbl=f"#{tid} {nm}"
            try: th=20; tw=int(draw.textlength(lbl,font=font))
            except: th=20; tw=len(lbl)*9
            draw.rectangle([X1,Y1-th-4,X1+tw+6,Y1], fill=(0,128,0))
            draw.text((X1+3,Y1-th-2), lbl, fill=(255,255,255), font=font)

        # Right panel
        sx0 = VID_W
        ts_now = time.strftime("%m-%d-%y %H:%M", time.localtime())
        header_lines = ["DELIVERY SERVICES SEEN:"]

        # --- draw delivery today list ---
        dl = _delivery_today_lines()
        panel_title = "DELIVERY SERVICES SEEN:"
        # draw title bar (you already have your red/green box code; reuse variables)
        # Write title
        put_text(panel, panel_title)
        # Then each entry on its own two lines
        for ln in dl:
            put_text(panel, ln)
        # --- end delivery list ---
        
        # --- draw delivery today list ---
        dl = _delivery_today_lines()
        panel_title = "DELIVERY SERVICES SEEN:"
        # draw title bar (you already have your red/green box code; reuse variables)
        # Write title
        put_text(panel, panel_title)
        # Then each entry on its own two lines
        for ln in dl:
            put_text(panel, ln)
        # --- end delivery list ---
                if present:
            for svc in sorted(present_set):
                header_lines += [svc.upper(), ts_now]
        else:
            header_lines += ["NONE", ts_now]

        try: font_big2 = ImageFont.truetype("DejaVuSans.ttf", 22)
        except: font_big2 = font
        line_h = 24
        top_pad, bottom_pad, side_pad = 8, 8, 10
        block_h = max(top_pad + bottom_pad + line_h*len(header_lines), 38)
        color = (0,160,0) if present else (120,0,0)
        draw.rectangle([sx0, 0, OUT_W-1, block_h], fill=color)
        y = top_pad
        for line in header_lines:
            draw.text((sx0+side_pad, y), line, fill=(255,255,255), font=font_big2); y += line_h

        # Objects list bottom half
        y = OUT_H//2 + 10
        draw.text((sx0+12,y), "Objects", fill=(255,255,255), font=font_big2); y+=28
        counts={}
        for t in stable.values():
            counts[t["clsname"]] = counts.get(t["clsname"],0)+1
        if counts:
            for k in sorted(counts, key=lambda k:(-counts[k],k)):
                draw.text((sx0+12,y), f"{k} Ã—{counts[k]}", fill=(220,220,220), font=font); y+=22
        else:
            draw.text((sx0+12,y), "None", fill=(160,160,160), font=font)

        # Timestamp bottom-left of video
        ts_str = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        try: ts_tw = int(draw.textlength(ts_str, font=font))
        except: ts_tw = len(ts_str)*9
        ts_th = 20; pad_=6
        bx1, by1 = 6, VID_H - (ts_th + pad_*2) - 6
        bx2, by2 = bx1 + ts_tw + pad_*2, VID_H - 6
        draw.rectangle([bx1, by1, bx2, by2], fill=(0,0,0))
        draw.text((bx1+pad_, by1+pad_), ts_str, fill=(255,255,255), font=font)

        cur_meta={
            "ok": True,
            "ts":time.time(),
            "engines":{"delivery":ENG_DEL, "coco":ENG_COCO},
            "models":{"delivery":DEL_M if DEL_OK else "missing",
                      "coco":COCO_M  if COCO_OK else "missing"},
            "conf":{"delivery":CONF_DEL,"coco":CONF_COCO},
            "nms":NMS_THR,"minarea":MIN_AREA,"tiou":IOU_KEEP,"minhit":MIN_HITS,
            "delivery":{k:(k in set(x.lower() for x in counts.keys())) for k in DELIVERY_KEYS},
            "objects":[{"id":int(tid),"class":t["clsname"],"box":[float(v) for v in t["box"]]}
                       for tid,t in sorted({tid:t for tid,t in stable.items()}.items())],
            "ids":sorted(list({tid for tid in stable.keys()}))
        }

        buf=io.BytesIO(); canvas.save(buf, format="JPEG", quality=80); cur_frame=buf.getvalue()
        dt=time.time()-t0; time.sleep(max(0.0, 0.5-dt))
# ===== API =====
def mjpeg_gen():
    boundary="frame"
    while True:
        fr=cur_frame
        if fr is None: time.sleep(0.05); continue
        yield (b"--"+boundary.encode()+b"\r\nContent-Type: image/jpeg\r\nContent-Length: "+
               str(len(fr)).encode()+b"\r\n\r\n"+fr+b"\r\n")

app = FastAPI()
@app.get("/stream.mjpg")
def stream():  return StreamingResponse(mjpeg_gen(), media_type="multipart/x-mixed-replace; boundary=frame")
@app.get("/objects")
def objects(): return JSONResponse(cur_meta if cur_meta else {"ok": False})
@app.get("/health")
def health():  return JSONResponse(cur_meta if cur_meta else {"ok": False})
@app.post("/simulate_delivery")
def simulate(svc: str):
    svc = (svc or "").lower().strip()
    if svc not in DELIVERY_KEYS:
        return {"ok": False, "error": "use one of: amazon/ups/fedex/usps"}
    ts = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    mqtt_publish({"timestamp": ts, "services": [svc]})
    return {"ok": True}

if __name__ == "__main__":
    mqtt_connect()
    th = threading.Thread(target=detect_and_render, daemon=True); th.start()
    uvicorn.run(app, host="0.0.0.0", port=8099, log_level="info")

# --- MAILCAM_NOTIFY_MQTT ---
MQTT_HOST = os.getenv('MAILCAM_MQTT_HOST','10.0.0.2')
MQTT_USER = os.getenv('MAILCAM_MQTT_USER','delivery')
MQTT_PASS = os.getenv('MAILCAM_MQTT_PASS','changeme')
MQTT_TOPIC= os.getenv('MAILCAM_MQTT_TOPIC','home/mailcam/delivery')
NOTIFY_COOLDOWN = float(os.getenv('MAILCAM_NOTIFY_COOLDOWN','90'))
_last_sent = {'seen':None,'t':0}

def _mqtt_client():
    try:
        c = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
    except Exception:
        c = mqtt.Client()
    if MQTT_USER:
        c.username_pw_set(MQTT_USER, MQTT_PASS or None)
    c.connect(MQTT_HOST, 1883, 30)
    return c

def notify_delivery(seen_set, snapshot_url=None):
    '''Publish when the set of brands changes, with cooldown.'''
    now=time.time()
    global _last_sent
    prev=_last_sent.get('seen')
    if prev==seen_set and (now - _last_sent.get('t',0)) < NOTIFY_COOLDOWN:
        return
    payload={'seen':sorted(list(seen_set)),
             'ts':now,
             'snapshot': snapshot_url}
    try:
        c=_mqtt_client()
        c.publish(MQTT_TOPIC, json.dumps(payload), qos=1, retain=False)
        c.disconnect()
        _last_sent={'seen':seen_set.copy(), 't':now}
    except Exception as e:
        print('MQTT notify error:',e,file=sys.stderr)
# --- MAILCAM_NOTIFY_MQTT --- end

# --- MAILCAM_DELIVERY_MQTT_STATE ---
MQTT_HOST = os.getenv('MAILCAM_MQTT_HOST','10.0.0.2')
MQTT_USER = os.getenv('MAILCAM_MQTT_USER','delivery')
MQTT_PASS = os.getenv('MAILCAM_MQTT_PASS','changeme')
TOPIC_STATE = os.getenv('MAILCAM_TOPIC_STATE','home/mailcam/delivery/state')
TOPIC_EVENT = os.getenv('MAILCAM_TOPIC_EVENT','home/mailcam/delivery/event')
SNAPSHOT_URL = os.getenv('MAILCAM_SOURCE','')
COOLDOWN_SEC = float(os.getenv('MAILCAM_NOTIFY_COOLDOWN','90'))
RESET_HOUR = int(os.getenv('MAILCAM_RESET_HOUR','3'))  # 3am local

_state_cache = {
    'prev_current': set(),
    'today': set(),
    'first_seen': {},   # brand -> epoch
    'next_reset': 0.0,
    'last_pub_t': 0.0,
}

def _mqtt():
    try:
        c = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
    except Exception:
        c = mqtt.Client()
    if MQTT_USER:
        c.username_pw_set(MQTT_USER, MQTT_PASS or None)
    c.connect(MQTT_HOST, 1883, 30)
    return c

def _calc_next_reset(now=None):
    from datetime import datetime, timedelta
    if now is None:
        now = time.time()
    dt = datetime.fromtimestamp(now)
    target = dt.replace(hour=RESET_HOUR, minute=0, second=0, microsecond=0)
    if dt >= target:
        target = target + timedelta(days=1)
    return target.timestamp()

def _maybe_reset_today(now=None):
    if now is None:
        now = time.time()
    if _state_cache['next_reset'] == 0.0:
        _state_cache['next_reset'] = _calc_next_reset(now)
    if now >= _state_cache['next_reset']:
        _state_cache['today'].clear()
        _state_cache['first_seen'].clear()
        _state_cache['next_reset'] = _calc_next_reset(now)

def _publish_state(current_set, now=None):
    if now is None: now = time.time()
    _maybe_reset_today(now)

    # Update rolling "today" set & first_seen stamps
    for b in current_set:
        if b not in _state_cache['today']:
            _state_cache['today'].add(b)
            if b not in _state_cache['first_seen']:
                _state_cache['first_seen'][b] = now

    # Detect entries (brands that just entered frame)
    entered = sorted(list(current_set - _state_cache['prev_current']))
    changed_current = (current_set != _state_cache['prev_current'])

    # Build payloads
    def iso(ts): 
        from datetime import datetime
        return datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S')

    payload_state = {
        'current': sorted(list(current_set)),
        'today':   sorted(list(_state_cache['today'])),
        'first_seen': {b: iso(t) for b,t in _state_cache['first_seen'].items()},
        'ts': now,
        'snapshot': SNAPSHOT_URL,
    }

    # Publish retained STATE whenever current set changes or once per cooldown
    publish_state = changed_current or (now - _state_cache['last_pub_t'] >= COOLDOWN_SEC)

    # EVENT only when something newly enters the frame
    payload_event = {
        'entered': entered,
        'current': sorted(list(current_set)),
        'today':   sorted(list(_state_cache['today'])),
        'ts': now,
        'snapshot': SNAPSHOT_URL,
    }

    try:
        c = _mqtt()
        if publish_state:
            c.publish(TOPIC_STATE, json.dumps(payload_state), qos=1, retain=True)
            _state_cache['last_pub_t'] = now
        if entered:
            c.publish(TOPIC_EVENT, json.dumps(payload_event), qos=1, retain=False)
        c.disconnect()
    except Exception as e:
        print('MQTT publish error:', e, file=sys.stderr)

    _state_cache['prev_current'] = set(current_set)
# --- MAILCAM_DELIVERY_MQTT_STATE --- end
